============================================================
          Overview of the "concurrentgen" collector
============================================================

Goal: reduce the total real time by moving a part of the GC to its own
thread that can run in parallel with the main execution thread.

On current modern hardware with at least two cores, the two cores can
read the same area of memory concurrently.  If one of the cores writes
to this area, then I believe that the core doing the writing works at
full speed, whereas the core doing the reading suffers from waiting for
the data to move to it; but it's still ok because the data usually moves
in a cache-to-cache bus, not via the main memory.  Also, if an area of
memory is written to by one core, and then read and written to by the
other core only, then performance is fine.  The bad case is the one in
which both cores continously read and write the same area of memory.

So, assuming that the main thread reads and writes to random objects all
the time, it means that the GC thread should *only read* from the
objects.  Conversely, the data structures built by the GC thread should
only be *read* from the main thread.  In particular: when the GC thread
does marking, it should use off-objects bits; and sweeping should be
done by adding free objects to lists that are not chained lists.  In
this way the GC thread never writes to the object's memory.  Similarly,
for the same reason, the GC thread should not reset areas of memory to
zero in the background.

This goal is not reached so far: both threads read and write the object
mark byte; there are no off-objects bits.


************************************************************
  Minor collection cycles of the "concurrentgen" collector
************************************************************

Objects mark byte:

    cym: young objs (and all flagged objs)
    cam: aging objs
    com: old objs
    'S': static prebuilt objs with no heap pointer

cym = current_young_marker
cam = current_aging_marker
com = current_old_marker

The write barrier activates when writing into an object whose
mark byte is different from 'cym'.


------------------------------------------------------------

Step 1.  Only the mutator runs.

   old obj    flagged obj     old obj
                    |
                    |
                    v
                young obj...

Write barrier: change "old obj" to "flagged obj"
    (if mark != cym:
         mark = cym (used to be com or 'S')
         record the object in the "flagged" list)
    - note that we consider that flagged old objs are again young objects

------------------------------------------------------------

Step 2.  Preparation for running the collector.  (Still single-threaded.)

   - young objs -> aging objs
         (exchange the values of 'cam' and 'cym'.
          there was no 'cam' object, so now there is no 'cym' object)

   - collect roots; add roots and flagged objs to the "gray objs" list

   - unflag objs (i.e. empty the "flagged" list)

------------------------------------------------------------

Step 3.  Parallel execution of the collector, mark phase

   old obj    old obj     old obj

         aging obj   aging obj

   new young obj...


Collector thread:

    for each gray obj:
        skip obj if not an aging obj    (i.e. if mark != cam: continue)
        for each obj found by tracing:
            add to gray objs      (if not an aging obj, will be skipped later)
        gray obj -> black obj     (i.e. mark = com)

Write barrier:

   - perform as a "deletion barrier", detecting changes done to aging objs
        (i.e. if mark == cam,
                  mark = com
                  trace and add to gray objs)
   - also flag old-or-aging objs that point to new young objs
        (if mark != cym:
             mark = cym (used to be com or 'S')
             record the object in the "flagged" list)

Threading issues:

   - it's possible that both threads will trace the same object, if we're
     unlucky, but it does not have buggy effects
   - the "mark = com" in the collector thread can conflict with the
     "mark = cym" in the mutator write barrier, but again, it should not
     have buggy effects beyond occasionally triggering the write barrier
     twice on the same object, adding it twice in "flagged" (and never more)
   - it is essential to have "mark = com" _after_ tracing in the collector
     thread; otherwise, the write barrier in the mutator thread would be
     ignored in case it occurs between the two, and then the tracing done
     by the collector thread doesn't see the original values any more.
   - the detection of "we are done" in the collector thread needs to
     account for the write barrier currently tracing and adding more
     objects to "gray objs".

------------------------------------------------------------

Step 4.  Parallel execution of the collector, sweep phase

    for obj in previous nursery:
        if obj is "black":     (i.e. if mark != cam)
            make the obj old   (         nothing to do here, mark already ok)
        else:
            return the object to the available list
    after this there are no more aging objects

Write barrier:

   - flag old objs that point to new young objs
        (should not see any 'cam' object any more here)



************************************************************
  MAJOR collection cycles of the "concurrentgen" collector
************************************************************

Works mostly like a minor collection cycle.  The only difference
is in step 2, which is replaced with:


Step 2+.  Preparation for running a major collection.  (Still single-threaded.)

   - force a minor collection's marking step to occur sequentially
     (steps 2 and 3), to get rid of 'cym' objects.  Objects are left
     either 'cam' (non-marked) or 'com' (marked).

   - empty the "flagged" list

   - collect roots; add roots to the "gray objs" list

   - com <-> cam
         (exchange the values of 'com' and 'cam'.
          there are no 'cym' object right now.
          the newly 'com' objects are the ones marked unreachable above.)


Major collections only worry about old objects.  To avoid serializing
the complete major collection, we serialize the minor collection's
marking step that occurs first; the goal is to be sure that all objects
are in the 'com' state.  We can minimize the non-parallelized delay
introduced by this step by doing the major collection just after the
previous minor collection finished, when the quantity of new young
objects should still be small.
