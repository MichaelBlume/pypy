============================================================
          Overview of the "concurrentgen" collector
============================================================

Goal: reduce the total real time by moving a part of the GC to its own
thread that can run in parallel with the main execution thread.



************************************************************
  Global overview
************************************************************

The objects are never physically moving with this GC; in the pictures
below, they "move" only in the sense that their age changes.

Objects have 4 possible ages: "new" when they are newly allocated;
"aging" when they are in the process of being marked by the GC thread;
"old" when they survived a minor collection; and "static" is used to
mark the static prebuilt GC objects, at least until they grow a pointer
to a dynamic GC object.

We allocate new objects until 25% of the total RAM is reached:

            25%       25%                50%
        +-----------+-----------+-----------------------+
        |           |           |                       |
        |->new...   |  free     |     old objects       |
        +-----------+-----------+-----------------------+

When the 25% is full, the new objects become aging, and we do a minor
collection on them.  In parallel we continue to allocate more new
objects.

            25%       25%                50%
        +-----------+-----------+-----------------------+
        |           |  aging    |                       |
        |->new...   |collecting |     old objects       |
        +-----------+-----------+-----------------------+

When the minor collection finishes, the surviving objects (let's say 5%)
have become old, and the non-surviving ones (let's say 20%) become free
space again.

            25%       20%                55%
        +-----------+---------+-------------------------+
        |           |         |<                        |
        |->new...   |  free   |<      old objects       |
        +-----------+---------+-------------------------+

The limit on new objects is still fixed to 25% of the RAM.  When it is
full, we start the next minor collection with the aging objects using
25% of the RAM, and we only have 20% of space for further new objects:

            20%       25%                55%
        +---------+-----------+-------------------------+
        |         |<          |                         |
        |->new... |< aging    |       old objects       |
        +---------+-----------+-------------------------+

It is still likely that we finish the minor collection before the 20%
run out.  If we do, then we expand the limit from 20% back to the
original 25%, and continue running like above.

            25%       15%                60%
        +-----------+-------+---------------------------+
        |          >|       |<                          |
        |->new...  >| free  |<        old objects       |
        +-----------+-------+---------------------------+

We continue until the free fraction becomes so small (let's say 5%)
that during a minor collection we run out of these 5% for new objects
before the minor collection manages to finish:

         5%      25%                70%
        +--+-----------+--------------------------------+
        |  |<          |                                |
        |->|< aging    |         old objects            |
        +--+-----------+--------------------------------+

At this point we want a full collection to occur.  In order to do that,
we have to first wait for the minor collection to finish:

         5%      20%                75%
        +--+---------+----------------------------------+
        |wa|         |<                                 |
        |it|  free   |<          old objects            |
        +--+---------+----------------------------------+

Then we do "Step 2+" below, forcing another synchronous minor
collection.  (This is the only time during which the main thread has to
wait for the collector to finish; hopefully it is a very minor issue,
because it occurs only at the start of a major collection, and we wait
for: (1) the end of the previous minor collection, which should ideally
be almost done already; and (2) an extra complete minor collection, but
that occurs on less objects than usual -- above, 5% instead of 25%.)

            24%                     76%
        +-----------+-----------------------------------+
        |           |<                                  |
        |   free    |<           old objects            |
        +-----------+-----------------------------------+

The old objects are transformed into aging objects, and we start the
collection on them, while resuming the main thread:

            24%                     76%
        +-----------+-----------------------------------+
        |           |                                   |
        |->new..    |          aging objects            |
        +-----------+-----------------------------------+

Here, the limiting factor is that we would like the main thread to not
run out of its 24% while the major collection is in progress.  If it
does, then it has to be suspended and wait for the collector thread.
But hopefully, possibly with measures and tweaks to the numbers, the
major collection finishes first.  It finds a proportion of old objects
to be still alive.  A value above 50% means that the memory usage of the
actual program has grown; a value below 50% means that it has shrunk.
In any case we need to re-adjust the sizes of the other portions to keep
the ratio 25/25/50 of the very first picture above, changing the total
amount of RAM used by the process.  Say with 60% of the old RAM size:

            30%           30%                     60%
        +-------------+-------------+---------------------------+
        |            >|            >|          surviving        |
        |->new...    >|  free      >|         old objects       |
        +-------------+-------------+---------------------------+

And we continue as per the first picture above.

If the size of the surviving old objects shrinks instead of growing, we
might need to give less than a quarter to the free area, because the new
objects (24% above) might take more than a quarter of the new total RAM
size.  To avoid too many issues, we constrain the total RAM size to not
shrink too much at each major collection (something like: at most -30%).
Additionally we fix an absolute minimum (at least 6 MB), to avoid doing
a large number of tiny minor collections, ending up spending all of our
time in Step 2 scanning the stack of the process.



************************************************************
  Notes about running two threads
************************************************************

On current modern hardware with at least two cores, the two cores can
read the same area of memory concurrently.  If one of the cores writes
to this area, then I believe that the core doing the writing works at
full speed, whereas the core doing the reading suffers from waiting for
the data to move to it; but it's still ok because the data usually moves
in a cache-to-cache bus, not via the main memory.  Also, if an area of
memory is written to by one core, and then read and written to by the
other core only, then performance is fine.  The bad case is the one in
which both cores continously read and write the same area of memory.

So, assuming that the main thread reads and writes to random objects all
the time, it means that the GC thread should *only read* from the
objects.  Conversely, the data structures built by the GC thread should
only be *read* from the main thread.  In particular: when the GC thread
does marking, it should use off-objects bits; and sweeping should be
done by adding free objects to lists that are not chained lists.  In
this way the GC thread never writes to the object's memory.  Similarly,
for the same reason, the GC thread should not reset areas of memory to
zero in the background.

This goal is not reached so far: both threads read and write the object
mark byte; there are no off-objects bits.


************************************************************
  Minor collection cycles of the "concurrentgen" collector
************************************************************

Objects mark byte:

    cym: young objs (and all flagged objs)
    cam: aging objs
    com: old objs
    'S': static prebuilt objs with no heap pointer

cym = current_young_marker
cam = current_aging_marker
com = current_old_marker

The write barrier activates when writing into an object whose
mark byte is different from 'cym'.


------------------------------------------------------------

Step 1.  Only the mutator runs.

   old obj    flagged obj     old obj
                    |
                    |
                    v
                young obj...

Write barrier: change "old obj" to "flagged obj"
    (if mark != cym:
         mark = cym (used to be com or 'S')
         record the object in the "flagged" list)
    - note that we consider that flagged old objs are again young objects

------------------------------------------------------------

Step 2.  Preparation for running the collector.  (Still single-threaded.)

   - young objs -> aging objs
         (exchange the values of 'cam' and 'cym'.
          there was no 'cam' object, so now there is no 'cym' object)

   - collect roots; add roots and flagged objs to the "gray objs" list

   - unflag objs (i.e. empty the "flagged" list)

------------------------------------------------------------

Step 3.  Parallel execution of the collector, mark phase

   old obj    old obj     old obj

         aging obj   aging obj

   new young obj...


Collector thread:

    for each gray obj:
        skip obj if not an aging obj    (i.e. if mark != cam: continue)
        for each obj found by tracing:
            add to gray objs      (if not an aging obj, will be skipped later)
        gray obj -> black obj     (i.e. mark = com)

Write barrier:

   - perform as a "deletion barrier", detecting changes done to aging objs
        (i.e. if mark == cam,
                  mark = com
                  trace and add to gray objs)
   - also flag old-or-aging objs that point to new young objs
        (if mark != cym:
             mark = cym (used to be com or 'S')
             record the object in the "flagged" list)

Threading issues:

   - it's possible that both threads will trace the same object, if we're
     unlucky, but it does not have buggy effects
   - the "mark = com" in the collector thread can conflict with the
     "mark = cym" in the mutator write barrier, but again, it should not
     have buggy effects beyond occasionally triggering the write barrier
     twice on the same object, adding it twice in "flagged" (and never more)
   - it is essential to have "mark = com" _after_ tracing in the collector
     thread; otherwise, the write barrier in the mutator thread would be
     ignored in case it occurs between the two, and then the tracing done
     by the collector thread doesn't see the original values any more.
   - the detection of "we are done" in the collector thread needs to
     account for the write barrier currently tracing and adding more
     objects to "gray objs".

------------------------------------------------------------

Step 4.  Parallel execution of the collector, sweep phase

    for obj in previous nursery:
        if obj is "black":     (i.e. if mark != cam)
            make the obj old   (         nothing to do here, mark already ok)
        else:
            return the object to the available list
    after this there are no more aging objects

Write barrier:

   - flag old objs that point to new young objs
        (should not see any 'cam' object any more here)



************************************************************
  MAJOR collection cycles of the "concurrentgen" collector
************************************************************

Works mostly like a minor collection cycle.  The only difference
is in step 2, which is replaced with:


Step 2+.  Preparation for running a major collection.  (Still single-threaded.)

   - force a minor collection's marking step to occur sequentially
     (steps 2 and 3), to get rid of 'cym' objects.  Objects are left
     either 'cam' (non-marked) or 'com' (marked).

   - empty the "flagged" list

   - collect roots; add roots to the "gray objs" list

   - com <-> cam
         (exchange the values of 'com' and 'cam'.
          there are no 'cym' object right now.
          the newly 'com' objects are the ones marked unreachable above.)


Major collections only worry about old objects.  To avoid serializing
the complete major collection, we serialize the minor collection's
marking step that occurs first; the goal is to be sure that all objects
are in the 'com' state.  We can minimize the non-parallelized delay
introduced by this step by doing the major collection just after the
previous minor collection finished, when the quantity of new young
objects should still be small.
